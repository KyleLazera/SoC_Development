#include "uart.h"


/***********************************************
 * Communication Functions
 ***********************************************/

void set_baud_rate(uart_handle_t* self, uint32_t baud_rate)
{
	//Calculate the dvsr value to write into the registers
	//Sys clk freq is 100MHz
	uint32_t dvsr = ((SYS_CLK_FREQ * 1000000)/(16 * baud_rate) - 1);
	io_write(self->base_reg, DVSR_REG, dvsr);
}

void uart_init(uart_handle_t* self, uint32_t core_base_addr)
{
	//Set the base address of the peripheral
	self->base_reg = core_base_addr;
	//Set default baud rate to 9600
	set_baud_rate(self, 9600);
}

int rx_fifo_empty(uart_handle_t* self)
{
	int empty_flag;
	//Read the value from the read register and use a bit mask to isolate desired bit
	empty_flag = (io_read(self->base_reg, READ_DATA_REG)) & RX_EMPTY_MASK;
	//bit shift to the right by 8
	empty_flag = empty_flag >> 8;
	return empty_flag;
}

int tx_fifo_full(uart_handle_t* self)
{
	int full_flag;
	//read the value from read register and use bit mask to isolate desired bit
	full_flag = (io_read(self->base_reg, READ_DATA_REG)) & TX_FULL_MASK;
	//Bit shift the value
	full_flag = full_flag >> 9;
	return full_flag;
}

void tx_byte(uart_handle_t* self, uint8_t tx_byte)
{
	//Wait until tx fifo is not full so we can write into it
	while(tx_fifo_full(self)){};
	//Once the fifo is not full, write the desired value in
	io_write(self->base_reg, WR_DATA_REG, (uint32_t)tx_byte);
}

int rx_byte(uart_handle_t* self)
{
	uint32_t rd_data;

	//check if fifo is empty
	if(rx_fifo_empty(self))
		return -1;
	else
	{
		//Read from data reg and mask the desired bits
		rd_data = io_read(self->base_reg, READ_DATA_REG) & RX_DATA_MASK;
		//remove the read data from the fifo
		io_write(self->base_reg, RM_RD_DATA_REG, DUMMY_DATA);
		return rd_data;
	}
}

/**************************************************
 * Helper/Private Functions
 **************************************************/

/*
 * @brief Display a string by breaking it down & sending it as individual chars
 */
static void display_str(uart_handle_t* self, const char* str)
{
	//While there are still characters in the input string, send
	//each character and then increment the address to the next char
	while((uint8_t) *str){
		tx_byte(self, *str);
		str++;
	}
}

/*
 * @brief Convert a numerical input into a string to display
 * @param self: instance of the uart handle
 * @param num: value to print
 * @param base: base of the value (base 2 = binary, base 8 = octal etc.)
 * @param len: num of digits in string
 */
static void convert_num_to_str(uart_handle_t* self, int num, int base, int len)
{
	char buffer[33];		//Largest number of bits it can hold is 32 + null
	char* str, ch, sign;
	int remainder, num_digits;
	unsigned int value;

	//Error check for length - largest string of numbers is 32 digits
	if(len > 32)
		len = 32;

	//Check if number is negative
	if(base == 10 && num < 0)
	{
		//Assign value and sign for negative
		value = (unsigned)(-num);
		sign = '-';
	}
	else
	{
		//Assign value and sign as positive
		value = (unsigned)num;
		sign = ' ';
	}

	/***** Conversion Logic ********/
	//Start from the end of the buffer and pad the number with 0's in front of it
	str = &buffer[33];
	//Set null terminator
	*str = '\0';
	num_digits = 0;
	do{
		str--;
		remainder = value % base;
		value = value / base;
		if(remainder < 10)
			ch = (char)remainder + '0';
		else
			ch = (char)remainder - 10 + 'a';
		*str = ch;
		num_digits--;
	} while(value);
	//Attach the sign for a negative value
	if(sign == '-')
	{
		str--;
		*str = sign;
	}
}


/*********************************************
 * Display Functions
 *********************************************/

void disp_char(uart_handle_t* self, char ch)
{
	//Transmit a singular character
	tx_byte(self, ch);
}

void disp_str(uart_handle_t* self, const char* str)
{
	display_str(self, str);
}

