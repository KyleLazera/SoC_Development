`timescale 1ns / 1ps

/*
* This module is a uart receiver module. It receives the data coming from the external world
* and outputs the data.
*/
module uart_rx
#(
    parameter DATA_BITS,    //Max number of data bits
              OVRSAMPLING
)
(
    input logic clk, reset,
    input logic s_tick,                 //Input signal generated by the baudrate controller
    input logic rx,                     //Data coming into the UARt receiver
    input logic rx_fifo_full,
    //Configurable Bits
    input logic [3:0] d_bits,           //Number of data bits to read
    input logic [5:0] stop_ticks,       //Number of stop ticks to count num of stop bits
    input logic parity_en,              //Enable or disable parity
    input logic parity_pol,             //Determine whether polarity is even or odd (1 = even, 0 = odd)
    //Flags
    output logic parity_err,            //Flag indicating mismatching parity bit 
    output logic frame_err,             //Flag indicating a mismatched uart frame
    output logic overflow_err,          //Flag indicating rx fifo is full 
    output logic rx_done,               //Flag indicating reception is complete (all bits read)
    //Output Data
    output logic [DATA_BITS-1:0] dout
);

/*********** Varibale declerations ***************/
//State Machine decleration
typedef enum {idle,                 //Initial starting state (when rx == 0 indicating start bit) switch states
              start,                //State to count the start bit ticks (7)
              data,                 //State to read the data
              parity,               //Compare the calculated parity to the recieved parity
              stop} state_type;     //State to read the stop bits and signal completion

/*********** Signal Declerations ***************/
state_type state_reg, state_next;
logic [5:0] s_reg, s_next;                    //reg to keep track of smapling ticks (needs to count up to 15)
logic [2:0] n_reg, n_next;                    //reg to keep track of number of data bits recieved
logic [DATA_BITS-1:0] b_reg, b_next;          //reg to store the data coming into the receiever module
logic parity_bit;                               //Output of the parity circuit
logic par_din_xor, parity_temp;                 //Temporary wires used to store intermediary values in the parity combinational circuit

/********** UART Receiver Logic ****************/
always_ff @(posedge clk, posedge reset)
begin
    if(reset)
        begin
            state_reg <= idle;
            s_reg <= 0;
            n_reg <= 0;
            b_reg <= 0;
        end
    else
        begin
            state_reg <= state_next;
            s_reg <= s_next;
            n_reg <= n_next;
            b_reg <= b_next;
        end     
end

//Next State Logic
always_comb
begin
    //Default signals
    state_next = state_reg;
    s_next = s_reg;
    n_next = n_reg;
    b_next = b_reg;
    rx_done = 1'b0;
    //State Machine logic
    case(state_reg)
        idle:
        begin
            //If rx goes low (indicating start bit)
            if(~rx)
                begin
                    frame_err = 1'b0;
                    parity_err = 1'b0;
                    state_next = start;
                    s_next = 0;
                    b_next = 0;
                end        
        end
        start:
        begin
            parity_err = 1'b0;
            frame_err = 1'b0;
            //If tick from baud rate has been received 
            if(s_tick)
            begin
                //Once 7 ticks have been counted begin reading the data
                if(s_reg == 7)
                begin
                    state_next = data;
                    s_next = 0;
                    n_next = 0;
                end
                else
                    s_next = s_reg + 1;
            end                              
        end 
        data:
        begin
            parity_err = 1'b0;
            frame_err = 1'b0;
            if(s_tick)
            begin
                //if 15 ticks have been counted
                if(s_reg == 15)
                begin
                    s_next = 0;                                     //Reset tick counter
                    b_next = (d_bits[3]) ? {rx, b_reg[7:1]}         //Shift the rx data into a register
                              :{1'b0, rx, b_reg[6:1]};                       
                    if(n_reg == (d_bits - 1))                        //If we have counted all the data bits
                        state_next = (parity_en) ? parity : stop;
                    else
                        n_next = n_reg + 1;
                end
                else
                    s_next = s_reg + 1;
            end
        end 
        parity:
        begin
            if(s_tick)
            begin
                if(s_reg == 15)
                begin
                    s_next = 0;
                    if(parity_bit != rx)
                        //If parity does not match raise the flag indicating the parity error
                        parity_err = 1'b1;

                    state_next = stop;
                end
                else
                    s_next = s_reg + 1;
            end
        end
        stop:
        begin
            if(s_tick)
            begin
                if(s_reg == (stop_ticks - 1))
                begin
                    //If stop bit is not 1, this indicates a frame error
                    //In the presence of a frame error, stop reading data a reset must be used 
                    if(~rx)
                        frame_err = 1'b1;
                    else
                        state_next = idle;
                        rx_done = 1'b1;
                        
                        if(rx_fifo_full)
                            overflow_err = 1'b1;
                        else
                            overflow_err = 1'b0;
                end
                else
                    s_next = s_reg + 1;
            end
        end     
    endcase
end

//Combinational Logic for Parity circuit
always_comb
begin
    //XOR the first 6 data in bits
    par_din_xor = (b_reg[0] ^ b_reg[1]) ^ (b_reg[2] ^ b_reg[3]) ^ (b_reg[4] ^ b_reg[5]);
    //Depending on the number of data bits - either XOR the 7th and 8th data with the above wire
    //Or XOR the above wire with the 7th data input - option depends upon msb of the d_bits wire
    parity_temp = par_din_xor ^ ((d_bits[3]) ? (b_reg[6] ^ b_reg[7]) : (b_reg[6]));
    //Determine whether the parity bit is even or odd
    parity_bit = (parity_pol) ? parity_temp : ~parity_temp;
end

//Output logic
assign dout = b_reg;


endmodule
